# Aliaport — Barınma Modülü (Barınma Kontratları) Replit Görevi

Bu görev, **Aliaport liman yönetim sistemi** içinde **Barınma (konaklama / iskele bağlama) sözleşmeleri** modülünü, mevcut ZIP proje yapısını kullanarak **gerçek backend API + React frontend** ile çalışır hale getirmek içindir.

Lütfen aşağıdaki adımları, **zaten Replit ortamında bulunan Aliaport ZIP projesi** üzerinden uygula. Kullanıcı şu anda **hiç kod yazmıyor**, tüm geliştirmeyi sen yapıyorsun.

---

## 0. Genel Çerçeve

- Backend: `FastAPI + SQLite` (zaten çalışan: `/api/cari`, `/api/motorbot`, `/api/mb-trip`, `/api/hizmet`, `/api/exchange-rate`)
- Frontend: `React + Vite` (aktif modüller: CariModule, MotorbotModule, SeferModule, HizmetModule, Kurlar entegrasyonu)
- Amaç: **Barınma (konaklama) kontrat modülünü**, mevcut mimariye **uyumlu** şekilde eklemek.

> Önemli kural: **Var olan şemalara ve type tanımlarına sadık kal.** Yeni bir şey uydurman gerekiyorsa, onu da temiz ve minimal tut; ama önce mutlaka mevcut dosyalara bak.

---

## 1. Mevcut Sözleşme / Barınma Tasarımını Analiz Et

### 1.1. Repo içindeki dokümanları tara

Aşadaki dosya/klasörleri incele, barınma / sözleşme ile ilgili tip ve şema var mı kontrol et:

- `API_SQL_MAPPING.md`
- `schema.sql`
- `docs/` veya `design/` benzeri klasörler (varsa)
- Frontend tarafında:
  - `src/components/modules/` altında **Barınma, Sözleşme, Kontrat** geçen component isimleri
  - `src/lib/types/` içinde barınma / contract ile ilgili type veya interface tanımları
  - `src/lib/api/` altında barınma için tasarlanmış ama mock olan dosyalar

GÖREV:

- Barınma kontratı için **varsa** hazır **type** veya **SQL taslağı** bul.
- Bu contract’ı görev boyunca **tek gerçek kaynak (single source of truth)** olarak kullan.
- Eğer hem SQL hem TS interface varsa, **TS tarafındaki isimlendirmeyi frontend contract** olarak kabul et; SQL tarafını buna göre uyumla.

Kısa notlarını, kod içine yorum olarak ekleyebilirsin (ör: `# NOTE: Barınma sözleşmesi şeması API_SQL_MAPPING.md’den alındı`).

---

## 2. Backend — Barınma Contract Model ve Router

### 2.1. SQLAlchemy Model

Aşağıdaki prensiplere göre yeni bir model oluştur:

- Dosya: `app/models_barinma.py` (veya repo içinde kullanılan isim standardına uy)
- Base/engine: Mevcut modellerde hangi `Base` kullanılıyorsa **aynen onu kullan** (ör: `from app.database import Base`).
- Örnek alanlar (bunlar **yol gösterici**; kesin şema, bir önceki adımda bulduğun tasarıma göre şekillenmeli):

  - `Id` (INT, PK, identity)
  - `CariId` (INT, FK → `Cari.Id`)
  - `KontratNo` (NVARCHAR / TEXT)
  - `BaslangicTarihi` (DATE)
  - `BitisTarihi` (DATE, NULL olabilir)
  - `GemiAdi` veya `VesselName` (opsiyonel, tasarıma bağlı)
  - `Iskele` / `LimanBolgesi` (opsiyonel)
  - `GunlukUcret` (DECIMAL)
  - `ParaBirimi` (NVARCHAR, default `TRY`)
  - `AktifMi` (BIT / BOOLEAN, default `1 / True`)
  - `Notlar` (TEXT, opsiyonel)
  - `CreatedAt`, `UpdatedAt` (otomatik tarih alanları; projedeki diğer tablolara paralel tasarla)

> Eğer `schema.sql` veya `API_SQL_MAPPING.md` içinde barınma için daha detaylı şema varsa, **onu esas al** ve yukarıdaki listeyi sadece referans olarak düşün.

### 2.2. Pydantic Şemaları

- Dosya: `app/schemas_barinma.py`
- Patterns: `schemas_cari.py`, `schemas_motorbot.py` dosyalarındaki gibi:

  - `BarinmaBase`
  - `BarinmaCreate`
  - `BarinmaUpdate`
  - `BarinmaResponse`
  - `PaginatedBarinmaResponse` (listeleme için)

İsimlendirmede PascalCase (backend objesinde) kullan, **JSON response'da PascalCase** dönmeye devam et (frontend zaten mapper ile snake_case’e çeviriyor).

### 2.3. FastAPI Router

- Dosya: `app/router_barinma.py`
- Prefix: `/api/barinma`
- Tags: `["Barinma"]`
- CRUD endpoint’leri ekle:

  - `GET /api/barinma/` → pagination destekli liste
  - `GET /api/barinma/{id}` → tek kayıt
  - `POST /api/barinma/` → yeni sözleşme
  - `PUT /api/barinma/{id}` → güncelleme
  - `DELETE /api/barinma/{id}` → soft/hard delete (mevcut projedeki pattern’e uy)

**Önemli:**

- Pagination yapısı, `router_hizmet.py` veya `router_kurlar.py` içindeki **hazır paginated pattern** ile birebir aynı olsun.
- Exception ve 404 handling, projedeki mevcut router’larla uyumlu olsun.

### 2.4. Router’ı Uygulamaya Kaydet

- `app/aliaport_web.py` içinde:

  ```python
  from app.router_barinma import router as barinma_router

  app.include_router(barinma_router, prefix="/api/barinma", tags=["Barinma"])
  ```

Backend’i restart et ve şu testleri yap:

- `GET http://localhost:8000/api/barinma/`
- `POST http://localhost:8000/api/barinma/` (örnek body ile)
- `GET http://localhost:8000/api/barinma/?page=1&page_size=10`

Backend tarafı **hatasız** çalışır hale geldikten sonra frontende geç.

---

## 3. Frontend — API Client (src/lib/api/barinma.ts)

### 3.1. Yeni API Client Dosyası

- Dosya: `src/lib/api/barinma.ts`
- Referans olarak şu dosyalara bak:

  - `src/lib/api/hizmet.ts`
  - `src/lib/api/kurlar.ts`

Aynı pattern ile:

- `listBarinma`, `getBarinma`, `createBarinma`, `updateBarinma`, `deleteBarinma`
- Gerekirse: `searchBarinma` (contract no, cari, tarih aralığına göre filtre)

### 3.2. Field Mapping (Transformer)

Backend JSON (örnek, PascalCase):

```json
{
  "Id": 1,
  "CariId": 3,
  "KontratNo": "BAR-2025-001",
  "BaslangicTarihi": "2025-01-01",
  "BitisTarihi": "2025-12-31",
  "GunlukUcret": "1500.00",
  "ParaBirimi": "USD",
  "AktifMi": true,
  "CreatedAt": "2025-11-20T22:38:29"
}
```

Frontend state (snake_case örnek):

```ts
{
  id: 1,
  cari_id: 3,
  kontrat_no: "BAR-2025-001",
  baslangic_tarihi: "2025-01-01",
  bitis_tarihi: "2025-12-31",
  gunluk_ucret: 1500.0,
  currency: "USD",
  is_active: true,
  created_at: "2025-11-20T22:38:29"
}
```

**Yapılacak:**

- Backend → Frontend için `transformBarinmaResponse`
- Liste için `transformBarinmaListResponse` (pagination’ı da dönüştür)
- DECIMAL alanlar backend’den `string` geldiği için `parseFloat` ile number’a çevir.

---

## 4. Frontend — BarınmaModule Component

### 4.1. Component Dosyası

- Dosya: `src/components/modules/BarinmaModule.tsx`

Tasarım ve UX için referans:

- `MotorbotModule.tsx`
- `SeferModule.tsx`
- `HizmetModule.tsx`

Minimum fonksiyonellik:

- Barınma sözleşmelerini listeleme (tablo veya kart)
- Yeni sözleşme eklemek için form
- En azından **KontratNo, Cari, Tarih aralığı, Günlük ücret, Para birimi, Aktif/Pasif** alanlarını yönet.
- Kayıt eklendiğinde/güncellendiğinde **toast** ile bilgi ver (Sonner kullanımı mevcut modüllerle aynı olsun).

### 4.2. Cari ve Diğer Bağımlılıklar

- Cari seçimi için mevcut `Cari` API’sini kullan.
- Gerekirse motorbot / gemi seçimi için `Motorbot` API’sini kullan (bu ilişki tasarımda varsa).

---

## 5. App.tsx — Menüye Entegrasyon ve Placeholder Kaldırma

### 5.1. Router / Sayfa Anahtarı

Projede `currentPage` state’i ile çalışan bir navigation yapısı var.

- `Barınma` için kullanılan `currentPage` değerini tespit et (ör: `"barinma-module"` veya `"barinma-sozlesmeleri"`).
- `App.tsx` içinde:

  - PlaceholderModule gösterilen yerlerden **Barınma** sayfasını çıkar,
  - Bunun yerine `BarinmaModule` componentini render et.

Örnek (prensip olarak):

```tsx
{currentPage === "barinma-module" && (
  <BarinmaModule
    onNavigateHome={handleBackToMenu}
    onNavigateBack={handleGoBack}
  />
)}
```

Placeholder koşulundan `"barinma-module"` anahtarını çıkar.

---

## 6. Test Planı

Aşağıdaki testleri sırayla yap:

1. **Backend testleri (curl veya HTTP Client ile):**  
   - `GET /api/barinma/` → 200, boş liste
   - `POST /api/barinma/` → 201/200, JSON döner
   - `GET /api/barinma/?page=1&page_size=10` → pagination yapısı doğru

2. **Frontend testleri (tarayıcı üzerinden):**
   - Dashboard açılıyor mu? (hatasız)
   - Menüden **Barınma** seçildiğinde:
     - Placeholder yerine gerçek BarınmaModule geliyor mu?
     - Liste boşken “kayıt yok” durumu düzgün mü?
     - Yeni sözleşme ekleyince:
       - API çağrısı başarılı mı?
       - Toast çıkıyor mu?
       - Liste güncelleniyor mu?

3. **Regresyon:**
   - Cari, Motorbot, Sefer ve Hizmet modüllerinde hata oluşmadığından emin ol.
   - Konsolda TypeScript/LSP hatası kalmamalı.

---

## 7. Teslimat

Bu görevi tamamlarken:

- Yaptığın önemli kararları (özellikle şema tasarımı ile ilgili) kod içinde `// NOTE:` şeklinde yorumlayabilirsin.
- replit.md dosyasına kısa bir bölüm ekleyip:

  - Barınma modülünün artık backend + frontend entegre çalıştığını,
  - Endpoint özetini,
  - Temel kullanım senaryosunu

  not olarak düşebilirsin.

Görev tamamlandığında:

- Uygulama açıldığında **Barınma** menü kalemi gerçek, API’ye bağlı bir modül olarak çalışmalı.
- Kullanıcı Replit tarafında **hiç elle kod yazmadan** bu modülü kullanabilir durumda olmalı.
